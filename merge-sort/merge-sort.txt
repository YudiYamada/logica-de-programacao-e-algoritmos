Merge Sort e Nota√ß√£o Big O (JavaScript)

O que √© o Merge Sort
--------------------
O Merge Sort √© um algoritmo de ordena√ß√£o baseado na t√©cnica "Dividir e Conquistar".
Ele divide o array em partes menores, ordena essas partes e depois mescla (merge) os resultados em um array final ordenado.

Como funciona:
1. Divis√£o: o array √© dividido recursivamente em duas metades at√© que cada subarray tenha apenas um elemento.
2. Conquista: cada subarray √© considerado ordenado (j√° que cont√©m apenas um elemento).
3. Combina√ß√£o (Merge): os subarrays s√£o mesclados em pares, comparando elementos e formando arrays maiores j√° ordenados.
4. Resultado final: ao final das mesclagens, o array completo estar√° ordenado.

Exemplo em JavaScript
---------------------
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const meio = Math.floor(arr.length / 2);
  const esquerda = mergeSort(arr.slice(0, meio));
  const direita = mergeSort(arr.slice(meio));

  return merge(esquerda, direita);
}

function merge(esquerda, direita) {
  let resultado = [];
  let i = 0, j = 0;

  while (i < esquerda.length && j < direita.length) {
    if (esquerda[i] < direita[j]) {
      resultado.push(esquerda[i]);
      i++;
    } else {
      resultado.push(direita[j]);
      j++;
    }
  }

  return resultado.concat(esquerda.slice(i)).concat(direita.slice(j));
}

// Exemplo de uso:
const numeros = [38, 27, 43, 3, 9, 82, 10];
console.log(mergeSort(numeros));
// sa√≠da: [3, 9, 10, 27, 38, 43, 82]

Explica√ß√£o: 
üîπ Fun√ß√£o merge(arrLeft, arrRight)
  - O que faz:
    ‚Ä¢ Recebe dois subarrays j√° ordenados e combina em um √∫nico array tamb√©m ordenado.
  - Como funciona:
    ‚Ä¢ Compara elemento por elemento dos dois subarrays.
    ‚Ä¢ Vai colocando no array resultado (`arrResult`) sempre o menor dos dois valores.
    ‚Ä¢ Quando um dos subarrays acaba, concatena o restante do outro.
  -Responsabilidade:
      √â a parte da combina√ß√£o (merge) do algoritmo.
      üëâ Ela n√£o sabe dividir o array, s√≥ sabe juntar dois arrays ordenados.

üîπ Fun√ß√£o mergeSort(arr)
  - O que faz:
    ‚Ä¢ √â a fun√ß√£o recursiva que divide o array em metades at√© chegar em subarrays de tamanho 1.
  - Como funciona:
    ‚Ä¢ Se o array tem 1 elemento, j√° est√° ordenado ‚Üí retorna.
    ‚Ä¢ Caso contr√°rio, divide em duas metades (`left` e `right`).
    ‚Ä¢ Chama recursivamente `mergeSort` para ordenar cada metade.
    ‚Ä¢ Usa a fun√ß√£o `merge` para juntar as duas metades ordenadas.
  - Responsabilidade:
    √â a parte da divis√£o e recurs√£o do algoritmo.
    üëâ Ela n√£o sabe combinar arrays, s√≥ sabe dividir e delegar a jun√ß√£o para `merge`.

‚ùì Por que n√£o d√° para usar s√≥ uma fun√ß√£o?
  - Se voc√™ tivesse apenas `merge`, ela n√£o conseguiria ordenar o array inteiro, porque s√≥ sabe juntar arrays j√° ordenados.
  - Se voc√™ tivesse apenas `mergeSort`, faltaria a l√≥gica de como juntar as metades ordenadas ‚Äî sem merge, voc√™ ficaria com duas listas ordenadas separadas, mas n√£o teria o array final.
Ou seja:
  - mergeSort ‚Üí divide e organiza a recurs√£o.
  - merge ‚Üí combina os peda√ßos ordenados.
Eles se complementam: uma sem a outra n√£o resolve o problema.

üëâ Pense assim:
  - mergeSort √© o arquiteto que planeja a divis√£o do trabalho.
  - merge √© o pedreiro que realmente junta as pe√ßas.
  Sem arquiteto, n√£o h√° plano; sem pedreiro, n√£o h√° constru√ß√£o.

Complexidade do Merge Sort
--------------------------
Tempo: O(n log n) em todos os casos (melhor, pior e m√©dio).
Espa√ßo: O(n), pois precisa de mem√≥ria extra para armazenar subarrays.

Melhor, Pior e Caso M√©dio
-------------------------
Melhor caso: O(n log n)
Pior caso: O(n log n)
Caso m√©dio: O(n log n)

Como reconhecer um algoritmo O(n log n)
---------------------------------------
- Divide o problema em partes menores (recurs√£o).
- Cada divis√£o gera log n n√≠veis de recurs√£o.
- Em cada n√≠vel, percorre todos os elementos (n).
- Padr√£o t√≠pico: Divide and Conquer.

Compara√ß√£o com outros algoritmos
--------------------------------
O(1)       ‚Üí Acesso direto em array
O(log n)   ‚Üí Busca Bin√°ria
O(n)       ‚Üí Busca Linear
O(n log n) ‚Üí Merge Sort, Quick Sort
O(n¬≤)      ‚Üí Bubble Sort

Resumo Final
------------
Algoritmo: Ordena dividindo o array em partes menores e mesclando resultados.
Complexidade: O(n log n) em todos os casos.
Espa√ßo extra: O(n).
Motivo: Divide em log n n√≠veis e percorre n elementos em cada n√≠vel.
Resposta curta: "O Merge Sort √© O(n log n), pois divide o array e mescla em cada n√≠vel."

Autor
-----
Yudi Yamada
LinkedIn: https://www.linkedin.com/in/yudi-yamada-0a10181b9/